/*
 * Copyright (c) 2026 Kory Heard
 *
 * SPDX-License-Identifier: BSD-2-Clause
 */

import CAudit
import Glibc

// MARK: - Audit Pipe

extension Audit {
    /// A connection to the audit pipe for real-time audit event monitoring.
    ///
    /// The audit pipe allows processes to receive audit records in real-time
    /// as they are generated by the kernel audit subsystem.
    ///
    /// Example:
    /// ```swift
    /// let pipe = try Audit.Pipe()
    /// try pipe.set(preselectionMask: Audit.Mask.all)
    ///
    /// while let record = try pipe.readRecord() {
    ///     // Process the audit record
    ///     for token in record.tokens {
    ///         print(token)
    ///     }
    /// }
    /// ```
    ///
    /// - Note: Opening the audit pipe typically requires root privileges.
    public final class Pipe {
        private let fd: Int32

        /// Opens a connection to the audit pipe.
        ///
        /// - Throws: `Audit.Error` if the pipe cannot be opened.
        /// - Note: Requires appropriate privileges.
        public init() throws {
            fd = open("/dev/auditpipe", O_RDONLY)
            if fd < 0 {
                throw Error(errno: errno)
            }
        }

        deinit {
            close(fd)
        }

        /// The file descriptor for the audit pipe.
        public var fileDescriptor: Int32 { fd }

        // MARK: - Queue Management

        /// Gets the current queue length (number of records waiting).
        ///
        /// - Returns: The number of records in the queue.
        /// - Throws: `Audit.Error` if the operation fails.
        public func queueLength() throws -> UInt32 {
            var qlen: UInt32 = 0
            if ioctl(fd, caudit_pipe_get_qlen_cmd(), &qlen) != 0 {
                throw Error(errno: errno)
            }
            return qlen
        }

        /// Gets the current queue limit.
        ///
        /// - Returns: The maximum number of records that can be queued.
        /// - Throws: `Audit.Error` if the operation fails.
        public func queueLimit() throws -> UInt32 {
            var qlimit: UInt32 = 0
            if ioctl(fd, caudit_pipe_get_qlimit_cmd(), &qlimit) != 0 {
                throw Error(errno: errno)
            }
            return qlimit
        }

        /// Sets the queue limit.
        ///
        /// - Parameter queueLimit: The new queue limit.
        /// - Throws: `Audit.Error` if the operation fails.
        public func set(queueLimit: UInt32) throws {
            var qlimit = queueLimit
            if ioctl(fd, caudit_pipe_set_qlimit_cmd(), &qlimit) != 0 {
                throw Error(errno: errno)
            }
        }

        /// Gets the minimum allowed queue limit.
        ///
        /// - Returns: The minimum queue limit.
        /// - Throws: `Audit.Error` if the operation fails.
        public func minQueueLimit() throws -> UInt32 {
            var qlimit: UInt32 = 0
            if ioctl(fd, caudit_pipe_get_qlimit_min_cmd(), &qlimit) != 0 {
                throw Error(errno: errno)
            }
            return qlimit
        }

        /// Gets the maximum allowed queue limit.
        ///
        /// - Returns: The maximum queue limit.
        /// - Throws: `Audit.Error` if the operation fails.
        public func maxQueueLimit() throws -> UInt32 {
            var qlimit: UInt32 = 0
            if ioctl(fd, caudit_pipe_get_qlimit_max_cmd(), &qlimit) != 0 {
                throw Error(errno: errno)
            }
            return qlimit
        }

        // MARK: - Preselection

        /// The preselection mode for the audit pipe.
        public enum PreselectionMode: Int32 {
            /// Follow the global audit trail preselection.
            case trail = 1  // AUDITPIPE_PRESELECT_MODE_TRAIL
            /// Use local preselection settings.
            case local = 2  // AUDITPIPE_PRESELECT_MODE_LOCAL
        }

        /// Gets the current preselection mode.
        ///
        /// - Returns: The preselection mode.
        /// - Throws: `Audit.Error` if the operation fails.
        public func preselectionMode() throws -> PreselectionMode {
            var mode: Int32 = 0
            if ioctl(fd, caudit_pipe_get_preselect_mode_cmd(), &mode) != 0 {
                throw Error(errno: errno)
            }
            return PreselectionMode(rawValue: mode) ?? .trail
        }

        /// Sets the preselection mode.
        ///
        /// - Parameter preselectionMode: The new preselection mode.
        /// - Throws: `Audit.Error` if the operation fails.
        public func set(preselectionMode: PreselectionMode) throws {
            var m = preselectionMode.rawValue
            if ioctl(fd, caudit_pipe_set_preselect_mode_cmd(), &m) != 0 {
                throw Error(errno: errno)
            }
        }

        /// Gets the preselection mask for attributable events.
        ///
        /// - Returns: The current preselection mask.
        /// - Throws: `Audit.Error` if the operation fails.
        public func preselectionMask() throws -> Mask {
            var mask = au_mask_t()
            if ioctl(fd, caudit_pipe_get_preselect_flags_cmd(), &mask) != 0 {
                throw Error(errno: errno)
            }
            return Mask(from: mask)
        }

        /// Sets the preselection mask for attributable events.
        ///
        /// - Parameter preselectionMask: The new preselection mask.
        /// - Throws: `Audit.Error` if the operation fails.
        public func set(preselectionMask: Mask) throws {
            var m = preselectionMask.toC()
            if ioctl(fd, caudit_pipe_set_preselect_flags_cmd(), &m) != 0 {
                throw Error(errno: errno)
            }
        }

        /// Flushes all pending records from the queue.
        ///
        /// - Throws: `Audit.Error` if the operation fails.
        public func flush() throws {
            if ioctl(fd, caudit_pipe_flush_cmd()) != 0 {
                throw Error(errno: errno)
            }
        }

        // MARK: - Statistics

        /// Gets the number of records inserted into this pipe.
        ///
        /// - Returns: The insert count.
        /// - Throws: `Audit.Error` if the operation fails.
        public func insertCount() throws -> UInt64 {
            var count: UInt64 = 0
            if ioctl(fd, caudit_pipe_get_inserts_cmd(), &count) != 0 {
                throw Error(errno: errno)
            }
            return count
        }

        /// Gets the number of records read from this pipe.
        ///
        /// - Returns: The read count.
        /// - Throws: `Audit.Error` if the operation fails.
        public func readCount() throws -> UInt64 {
            var count: UInt64 = 0
            if ioctl(fd, caudit_pipe_get_reads_cmd(), &count) != 0 {
                throw Error(errno: errno)
            }
            return count
        }

        /// Gets the number of records dropped due to queue overflow.
        ///
        /// - Returns: The drop count.
        /// - Throws: `Audit.Error` if the operation fails.
        public func dropCount() throws -> UInt64 {
            var count: UInt64 = 0
            if ioctl(fd, caudit_pipe_get_drops_cmd(), &count) != 0 {
                throw Error(errno: errno)
            }
            return count
        }

        /// Gets the number of records truncated.
        ///
        /// - Returns: The truncate count.
        /// - Throws: `Audit.Error` if the operation fails.
        public func truncateCount() throws -> UInt64 {
            var count: UInt64 = 0
            if ioctl(fd, caudit_pipe_get_truncates_cmd(), &count) != 0 {
                throw Error(errno: errno)
            }
            return count
        }

        // MARK: - Reading Records

        /// Gets the maximum audit data size.
        ///
        /// - Returns: The maximum size in bytes.
        /// - Throws: `Audit.Error` if the operation fails.
        public func maxAuditDataSize() throws -> UInt32 {
            var size: UInt32 = 0
            if ioctl(fd, caudit_pipe_get_maxauditdata_cmd(), &size) != 0 {
                throw Error(errno: errno)
            }
            return size
        }

        /// Reads a raw audit record from the pipe.
        ///
        /// This method blocks until a record is available.
        ///
        /// - Returns: The raw record data, or `nil` on EOF.
        /// - Throws: `Audit.Error` if reading fails.
        public func readRawRecord() throws -> [UInt8]? {
            let maxSize = try maxAuditDataSize()
            var buffer = [UInt8](repeating: 0, count: Int(maxSize))

            let bytesRead = read(fd, &buffer, buffer.count)
            if bytesRead < 0 {
                throw Error(errno: errno)
            }
            if bytesRead == 0 {
                return nil  // EOF
            }

            return Array(buffer.prefix(bytesRead))
        }
    }
}
