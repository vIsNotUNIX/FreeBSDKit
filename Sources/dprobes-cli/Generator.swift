/*
 * dprobes-cli - Code Generator
 *
 * Copyright (c) 2026 Kory Heard
 * SPDX-License-Identifier: BSD-2-Clause
 */

/// Generates Swift probe code and DTrace provider definitions.
enum Generator {

    /// Generate Swift probe code for a provider.
    static func generateSwift(for provider: ProviderDefinition) -> String {
        let providerName = provider.name
        let enumName = toPascalCase(providerName) + "Probes"
        let stability = provider.stability ?? "Evolving"

        var output = """
            /*
             * Generated by dprobes-cli
             * Provider: \(providerName)
             * DO NOT EDIT - Regenerate from .dprobes file
             */

            // MARK: - External Probe Functions

            """

        for probe in provider.probes {
            output += generateExternDeclarations(provider: providerName, probe: probe)
        }

        output += """

            // MARK: - Provider: \(providerName)

            /// DTrace provider: \(providerName)
            /// Stability: \(stability)
            public enum \(enumName) {

            """

        for probe in provider.probes {
            output += generateProbeFunction(provider: providerName, probe: probe)
            output += "\n"
        }

        output += "}\n"
        return output
    }

    private static func generateExternDeclarations(provider: String, probe: ProbeDefinition) -> String {
        let probeFuncName = probe.name.replacingOccurrences(of: "_", with: "__")
        let enabledFuncName = "__dtraceenabled_\(provider)___\(probeFuncName)"
        let dtraceFuncName = "__dtrace_\(provider)___\(probeFuncName)"

        let argCount = probe.args?.count ?? 0
        let uintParams = argCount > 0
            ? (0..<argCount).map { "_ arg\($0): UInt" }.joined(separator: ", ")
            : ""

        return """

            @usableFromInline
            @_silgen_name("\(enabledFuncName)")
            func \(enabledFuncName)() -> Bool

            @usableFromInline
            @_silgen_name("\(dtraceFuncName)")
            func \(dtraceFuncName)(\(uintParams))

            """
    }

    private static func generateProbeFunction(provider: String, probe: ProbeDefinition) -> String {
        let funcName = toCamelCase(probe.name)
        let probeFuncName = probe.name.replacingOccurrences(of: "_", with: "__")
        let enabledFuncName = "__dtraceenabled_\(provider)___\(probeFuncName)"
        let dtraceFuncName = "__dtrace_\(provider)___\(probeFuncName)"

        let args = probe.args ?? []

        var params: [String] = []
        var argEvals: [String] = []
        var probeArgs: [String] = []
        var stringBindings: [(name: String, ptrName: String)] = []

        for (index, arg) in args.enumerated() {
            params.append("\(arg.name): @autoclosure () -> \(arg.type)")
            argEvals.append("let _\(arg.name) = \(arg.name)()")

            if arg.type == "String" {
                let ptrName = "_p\(index)"
                stringBindings.append((name: "_\(arg.name)", ptrName: ptrName))
                probeArgs.append("UInt(bitPattern: \(ptrName))")
            } else {
                probeArgs.append("UInt(truncatingIfNeeded: _\(arg.name))")
            }
        }

        let paramsJoined = params.joined(separator: ", ")
        let probeArgsJoined = probeArgs.joined(separator: ", ")

        var docComment = ""
        if let docs = probe.docs {
            docComment = "    /// \(docs)\n"
        }

        var bodyLines: [String] = []
        bodyLines.append("guard \(enabledFuncName)() else { return }")

        for eval in argEvals {
            bodyLines.append(eval)
        }

        if args.isEmpty {
            bodyLines.append("\(dtraceFuncName)()")
        } else if stringBindings.isEmpty {
            bodyLines.append("\(dtraceFuncName)(\(probeArgsJoined))")
        } else {
            for binding in stringBindings {
                bodyLines.append("\(binding.name).withCString { \(binding.ptrName) in")
            }
            let innerIndent = String(repeating: "    ", count: stringBindings.count)
            bodyLines.append("\(innerIndent)\(dtraceFuncName)(\(probeArgsJoined))")
            for i in (0..<stringBindings.count).reversed() {
                bodyLines.append(String(repeating: "    ", count: i) + "}")
            }
        }

        let body = bodyLines.joined(separator: "\n        ")

        return """
            \(docComment)    @inlinable
                public static func \(funcName)(\(paramsJoined)) {
                    \(body)
                }
            """
    }

    // MARK: - DTrace Provider Generation

    /// Generate DTrace provider definition (.d file).
    static func generateDTrace(for provider: ProviderDefinition) -> String {
        let providerName = provider.name
        let stability = provider.stability ?? "Evolving"

        var output = """
            /*
             * DTrace Provider Definition
             * Generated by dprobes-cli
             *
             * Compile with:
             *   dtrace -G -s \(providerName)_provider.d <objects>.o -o \(providerName)_provider.o
             */

            provider \(providerName) {

            """

        for probe in provider.probes {
            let args = probe.args ?? []
            let probeName = probe.name.replacingOccurrences(of: "_", with: "__")

            if let docs = probe.docs {
                output += "    /* \(docs) */\n"
            }

            if args.isEmpty {
                output += "    probe \(probeName)();\n"
            } else {
                let argDecls = args.map { "\(swiftTypeToCType($0.type)) \($0.name)" }.joined(separator: ", ")
                output += "    probe \(probeName)(\(argDecls));\n"
            }
            output += "\n"
        }

        output += """
            };

            #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) provider
            #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) module
            #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) function
            #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) name
            #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) args
            """

        return output
    }

    // MARK: - Helpers

    private static func toPascalCase(_ name: String) -> String {
        name.split(separator: "_")
            .map { $0.prefix(1).uppercased() + $0.dropFirst().lowercased() }
            .joined()
    }

    private static func toCamelCase(_ name: String) -> String {
        let parts = name.split(separator: "_")
        guard let first = parts.first else { return name }
        let rest = parts.dropFirst().map { $0.prefix(1).uppercased() + $0.dropFirst() }
        return String(first) + rest.joined()
    }

    private static func swiftTypeToCType(_ swiftType: String) -> String {
        // All types are validated before reaching here
        switch swiftType {
        case "Int8": return "int8_t"
        case "Int16": return "int16_t"
        case "Int32": return "int32_t"
        case "Int64", "Int": return "int64_t"
        case "UInt8": return "uint8_t"
        case "UInt16": return "uint16_t"
        case "UInt32": return "uint32_t"
        case "UInt64", "UInt": return "uint64_t"
        case "Bool": return "int32_t"
        case "String": return "char *"
        default:
            fatalError("Unvalidated type '\(swiftType)' reached code generator")
        }
    }
}
