/*
 * dprobes-gen - DProbes Code Generator
 *
 * Generates Swift probe code and DTrace provider definitions from
 * a JSON probe specification file (.dprobes).
 *
 * Usage:
 *   dprobes-gen <input.dprobes> [--output-dir <dir>]
 *
 * Copyright (c) 2026 Kory Heard
 * SPDX-License-Identifier: BSD-2-Clause
 */

import Foundation

// MARK: - Data Structures

struct ProbeDefinition: Codable {
    let name: String
    let args: [ProbeArgument]?
    let docs: String?
}

struct ProbeArgument: Codable {
    let name: String
    let type: String
}

struct ProviderDefinition: Codable {
    let name: String
    let stability: String?
    let probes: [ProbeDefinition]
}

// MARK: - Code Generation

func generateSwiftCode(provider: ProviderDefinition) -> String {
    let providerName = provider.name
    let sanitizedName = sanitizeIdentifier(providerName)
    let stability = provider.stability ?? "Evolving"

    var output = """
    /*
     * Generated by dprobes-gen
     * Provider: \(providerName)
     * DO NOT EDIT - Regenerate from .dprobes file
     */

    import Foundation

    // MARK: - External Probe Functions

    """

    // Generate external declarations for each probe
    for probe in provider.probes {
        let probeFuncName = probe.name.replacingOccurrences(of: "_", with: "__")
        let enabledFuncName = "__dtraceenabled_\(providerName)___\(probeFuncName)"
        let dtraceFuncName = "__dtrace_\(providerName)___\(probeFuncName)"

        let argCount = probe.args?.count ?? 0
        let uintParams = argCount > 0
            ? (0..<argCount).map { "_ arg\($0): UInt" }.joined(separator: ", ")
            : ""

        output += """

        @usableFromInline
        @_silgen_name("\(enabledFuncName)")
        func \(enabledFuncName)() -> Bool

        @usableFromInline
        @_silgen_name("\(dtraceFuncName)")
        func \(dtraceFuncName)(\(uintParams))

        """
    }

    // Generate the provider enum
    output += """

    // MARK: - Provider: \(providerName)

    /// DTrace provider: \(providerName)
    /// Stability: \(stability)
    public enum \(sanitizedName) {

    """

    // Generate each probe function
    for probe in provider.probes {
        let probeFunc = generateProbeFunction(provider: providerName, probe: probe)
        output += probeFunc
        output += "\n"
    }

    output += "}\n"

    return output
}

func generateProbeFunction(provider: String, probe: ProbeDefinition) -> String {
    let funcName = toCamelCase(probe.name)
    let probeFuncName = probe.name.replacingOccurrences(of: "_", with: "__")
    let enabledFuncName = "__dtraceenabled_\(provider)___\(probeFuncName)"
    let dtraceFuncName = "__dtrace_\(provider)___\(probeFuncName)"

    let args = probe.args ?? []

    // Build parameter list with @autoclosure
    var params: [String] = []
    var argEvals: [String] = []
    var probeArgs: [String] = []
    var stringBindings: [(name: String, ptrName: String)] = []

    for (index, arg) in args.enumerated() {
        params.append("\(arg.name): @autoclosure () -> \(arg.type)")
        argEvals.append("let _\(arg.name) = \(arg.name)()")

        if arg.type == "String" {
            let ptrName = "_p\(index)"
            stringBindings.append((name: "_\(arg.name)", ptrName: ptrName))
            probeArgs.append("UInt(bitPattern: \(ptrName))")
        } else {
            // For integer types, just convert to UInt
            probeArgs.append("UInt(truncatingIfNeeded: _\(arg.name))")
        }
    }

    let paramsJoined = params.joined(separator: ", ")
    let probeArgsJoined = probeArgs.joined(separator: ", ")

    // Build documentation
    var docComment = ""
    if let docs = probe.docs {
        docComment = "    /// \(docs)\n"
    }

    // Build function body - lines indented for inside the function
    var bodyLines: [String] = []

    bodyLines.append("guard \(enabledFuncName)() else { return }")

    if !args.isEmpty {
        for eval in argEvals {
            bodyLines.append(eval)
        }
    }

    if args.isEmpty {
        bodyLines.append("\(dtraceFuncName)()")
    } else if stringBindings.isEmpty {
        bodyLines.append("\(dtraceFuncName)(\(probeArgsJoined))")
    } else {
        // Has strings - build nested withCString
        var closingBraces: [String] = []
        for binding in stringBindings {
            bodyLines.append("\(binding.name).withCString { \(binding.ptrName) in")
            closingBraces.append("}")
        }
        // Add the dtrace call with proper indentation
        let innerIndent = String(repeating: "    ", count: stringBindings.count)
        bodyLines.append("\(innerIndent)\(dtraceFuncName)(\(probeArgsJoined))")
        // Close the braces
        for (index, brace) in closingBraces.reversed().enumerated() {
            let braceIndent = String(repeating: "    ", count: closingBraces.count - index - 1)
            bodyLines.append("\(braceIndent)\(brace)")
        }
    }

    let bodyIndent = "        "
    let body = bodyLines.joined(separator: "\n\(bodyIndent)")

    return """
    \(docComment)    @inlinable
        public static func \(funcName)(\(paramsJoined)) {
            \(body)
        }
    """
}

func generateDTraceProvider(provider: ProviderDefinition) -> String {
    let providerName = provider.name
    let stability = provider.stability ?? "Evolving"

    var output = """
    /*
     * DTrace Provider Definition
     * Generated by dprobes-gen
     *
     * Compile with:
     *   dtrace -h -s \(providerName)_provider.d
     *   dtrace -G -s \(providerName)_provider.d -o \(providerName)_provider.o
     */

    provider \(providerName) {

    """

    for probe in provider.probes {
        let args = probe.args ?? []
        let probeName = probe.name.replacingOccurrences(of: "_", with: "__")

        // Documentation
        if let docs = probe.docs {
            output += "    /* \(docs) */\n"
        }

        // Probe declaration
        if args.isEmpty {
            output += "    probe \(probeName)();\n"
        } else {
            let argDecls = args.map { arg in
                let cType = swiftTypeToCType(arg.type)
                return "\(cType) \(arg.name)"
            }.joined(separator: ", ")

            output += "    probe \(probeName)(\(argDecls));\n"
        }

        output += "\n"
    }

    output += """
    };

    #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) provider
    #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) module
    #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) function
    #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) name
    #pragma D attributes \(stability)/\(stability)/Common provider \(providerName) args
    """

    return output
}

// MARK: - Helpers

func sanitizeIdentifier(_ name: String) -> String {
    var result = name.replacingOccurrences(of: "-", with: "_")
    result = result.replacingOccurrences(of: ".", with: "_")
    if let first = result.first {
        result = first.uppercased() + result.dropFirst()
    }
    return result
}

/// Convert a probe name to camelCase Swift identifier
func toCamelCase(_ name: String) -> String {
    let parts = name.split(separator: "_")
    guard let first = parts.first else { return name }
    let rest = parts.dropFirst().map { $0.prefix(1).uppercased() + $0.dropFirst() }
    return String(first) + rest.joined()
}

func swiftTypeToCType(_ swiftType: String) -> String {
    switch swiftType {
    case "Int8": return "int8_t"
    case "Int16": return "int16_t"
    case "Int32": return "int32_t"
    case "Int64": return "int64_t"
    case "Int": return "int64_t"
    case "UInt8": return "uint8_t"
    case "UInt16": return "uint16_t"
    case "UInt32": return "uint32_t"
    case "UInt64": return "uint64_t"
    case "UInt": return "uint64_t"
    case "Bool": return "int32_t"
    case "String": return "char *"
    default: return "uintptr_t"
    }
}

// MARK: - JSON Parsing

func parseJSON(_ content: String) throws -> ProviderDefinition {
    guard let data = content.data(using: .utf8) else {
        throw GeneratorError.invalidInput("Invalid UTF-8 content")
    }

    let decoder = JSONDecoder()
    do {
        let provider = try decoder.decode(ProviderDefinition.self, from: data)
        guard !provider.name.isEmpty else {
            throw GeneratorError.missingProviderName
        }
        return provider
    } catch let error as DecodingError {
        switch error {
        case .keyNotFound(let key, _):
            throw GeneratorError.invalidInput("Missing required key: \(key.stringValue)")
        case .typeMismatch(_, let context):
            throw GeneratorError.invalidInput("Type mismatch: \(context.debugDescription)")
        case .dataCorrupted(let context):
            throw GeneratorError.invalidInput("Invalid JSON: \(context.debugDescription)")
        default:
            throw GeneratorError.invalidInput("JSON parsing error: \(error.localizedDescription)")
        }
    }
}

enum GeneratorError: Error, CustomStringConvertible {
    case missingProviderName
    case invalidInput(String)
    case fileNotFound(String)
    case validationFailed(String)

    var description: String {
        switch self {
        case .missingProviderName:
            return "Provider definition missing 'name' field"
        case .invalidInput(let msg):
            return "Invalid input: \(msg)"
        case .fileNotFound(let path):
            return "File not found: \(path)"
        case .validationFailed(let msg):
            return "Validation failed: \(msg)"
        }
    }
}

// MARK: - Validation

let maxProviderNameLength = 64
let maxProbeNameLength = 64
let maxArguments = 10
let validTypes = Set([
    "Int8", "Int16", "Int32", "Int64", "Int",
    "UInt8", "UInt16", "UInt32", "UInt64", "UInt",
    "Bool", "String"
])

func validateProvider(_ provider: ProviderDefinition) throws {
    // Validate provider name
    if provider.name.count > maxProviderNameLength {
        throw GeneratorError.validationFailed(
            "Provider name '\(provider.name)' exceeds \(maxProviderNameLength) character limit"
        )
    }

    if provider.name.contains(where: { !$0.isLetter && !$0.isNumber && $0 != "_" }) {
        throw GeneratorError.validationFailed(
            "Provider name '\(provider.name)' contains invalid characters (use letters, numbers, underscore)"
        )
    }

    // Validate each probe
    for probe in provider.probes {
        // Probe name length
        if probe.name.count > maxProbeNameLength {
            throw GeneratorError.validationFailed(
                "Probe name '\(probe.name)' exceeds \(maxProbeNameLength) character limit"
            )
        }

        // Probe name characters
        if probe.name.contains(where: { !$0.isLetter && !$0.isNumber && $0 != "_" }) {
            throw GeneratorError.validationFailed(
                "Probe name '\(probe.name)' contains invalid characters (use letters, numbers, underscore)"
            )
        }

        // Argument count
        let argCount = probe.args?.count ?? 0
        if argCount > maxArguments {
            throw GeneratorError.validationFailed(
                "Probe '\(probe.name)' has \(argCount) arguments (maximum is \(maxArguments))"
            )
        }

        // Validate argument types
        for arg in probe.args ?? [] {
            if !validTypes.contains(arg.type) {
                throw GeneratorError.validationFailed(
                    "Probe '\(probe.name)' argument '\(arg.name)' has unsupported type '\(arg.type)'. " +
                    "Supported: \(validTypes.sorted().joined(separator: ", "))"
                )
            }
        }
    }
}

// MARK: - Main

func main() throws {
    let args = CommandLine.arguments

    guard args.count >= 2 else {
        print("""
        Usage: dprobes-gen <input.dprobes> [--output-dir <dir>]

        Generates Swift probe code and DTrace provider definition from
        a JSON probe specification file.

        Example .dprobes file:
        {
          "name": "myapp",
          "stability": "Evolving",
          "probes": [
            {
              "name": "request_start",
              "docs": "Fires when request begins",
              "args": [
                { "name": "path", "type": "String" },
                { "name": "method", "type": "Int32" }
              ]
            },
            {
              "name": "request_done",
              "args": [
                { "name": "path", "type": "String" },
                { "name": "status", "type": "Int32" },
                { "name": "latency_ns", "type": "UInt64" }
              ]
            }
          ]
        }

        Supported types: Int8, Int16, Int32, Int64, Int,
                         UInt8, UInt16, UInt32, UInt64, UInt,
                         Bool, String

        Output:
          <provider>_probes.swift  - Swift probe functions
          <provider>_provider.d    - DTrace provider definition
        """)
        exit(1)
    }

    let inputPath = args[1]
    var outputDir = FileManager.default.currentDirectoryPath

    if args.count >= 4 && args[2] == "--output-dir" {
        outputDir = args[3]
    }

    // Read input file
    guard let content = try? String(contentsOfFile: inputPath, encoding: .utf8) else {
        throw GeneratorError.fileNotFound(inputPath)
    }

    // Parse JSON
    let provider = try parseJSON(content)

    // Validate provider
    try validateProvider(provider)

    // Generate Swift code
    let swiftCode = generateSwiftCode(provider: provider)
    let swiftPath = "\(outputDir)/\(provider.name)_probes.swift"
    try swiftCode.write(toFile: swiftPath, atomically: true, encoding: .utf8)
    print("Generated: \(swiftPath)")

    // Generate D provider file
    let dCode = generateDTraceProvider(provider: provider)
    let dPath = "\(outputDir)/\(provider.name)_provider.d"
    try dCode.write(toFile: dPath, atomically: true, encoding: .utf8)
    print("Generated: \(dPath)")

    print("""

    Next steps:
      1. Add \(provider.name)_probes.swift to your project
      2. Compile the provider:
         dtrace -h -s \(dPath)
         dtrace -G -s \(dPath) -o \(provider.name)_provider.o
      3. Link \(provider.name)_provider.o with your binary
    """)
}

do {
    try main()
} catch {
    fputs("Error: \(error)\n", stderr)
    exit(1)
}
